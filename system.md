# システム制御

## 0x0400_0300 - POSTFLG(Undocumented) - Post Boot / Debug Control (R/W)

最初のリセット後、BIOSはこのレジスタを0x01に初期化しリセットベクタ(0x000000)をさらに実行します。

このときレジスタがまだ0x01に設定されていることを感知すると、デバッグベクタ(0x0000_001c)に制御を渡します。

 bit  |  内容
----- | -----
0 | Undocumented. First Boot Flag  (0=First, 1=Further)
1-7 | Undocumented. Not used.

通常、デバッグハンドラは、カートリッジヘッダでデバッグフラグを検出しない限り制御を受け付けませんが、その場合は、(任天堂ロゴとブート遅延を省略することで) 簡略化されたブート処理へとリダイレクトします 

しかし、このレジスタを自動的にリセットせずにGBAを外部からリセットすることは可能なのかどうかはわかりません。

## 0x0400_0301 - HALTCNT(Undocumented) - 省電力モード制御レジスタ (W)

このレジスタに書き込みを行うことでGBAは省電力モードに移行します。

Haltモードでは、`IE & IF = 0`の限りCPUが停止し続けます。 これはCPUが割り込みを待つ間に電力消費を抑えるために使われます。

省電力モードは、サウンドや画面を含めたほとんどのハードウェアが停止します。

 bit  |  内容
----- | -----
0-6 | 未使用
7   | 省電力モード  (0=Halt, 1=Stop)

**基本的に、このレジスタに直接書き込むよりも BIOS関数 SWI2(Halt) または SWI3(Stop) を使用することが一般的に推奨されます。**

## 0x0400_0410 - Undocumented - 用途不明(1byte) (W)

BIOSはこのアドレスに0xFFを書き込みますが目的は不明です。

おそらくBIOSのバグでしょう。

## 0x0400_0800 - MEMCNT(Undocumented) - 内部メモリ制御レジスタ (R/W)

ハードウェアによって`0x0D00_0020`で初期化されます。

他のIOレジスタと違って、このレジスタはIOレジスタ用のメモリ領域にミラーされます。(ここから`0x0001_0000`刻み。 つまり0x0400_0800, 0x0401_0800, 0x0402_0800, ..., 0x04FF_0800)

```
  Bit    Dir   Expl.
  0      R/W   WRAM無効化フラグ (0=Normal, 1=IWRAM,EWRAMの両方無効化) 
  1-3    R/W   用途不明
  4      W?    用途不明 (常に0)
  5      R/W   EWRAM有効化フラグ (0=無効, 1=有効) (無効化するとIWRAMのミラー)
  6-23   W?    用途不明 (常に0)
  24-27  R/W   EWRAMウェイトステート (0-14 = 15..1 Waitstates, 15=Lockup)
  28-31  R/W   用途不明
```

EWRAMウェイトステート(`MEMCNT.24-27`) は デフォルトで`13`(`0x0D`)が入っていてウェイトステートが`2`になるようになっています。つまり 8/16/32bitアクセスに要するクロックサイクルは 3/3/6 となります。

### EWRAMのオーバークロック

EWRAMウェイトステート(`MEMCNT.24-27`) を `14`(`0x0E`) にするとウェイトステートは`1`になり、8/16/32bitアクセスに要するクロックサイクルが 2/2/4 となります。

EWRAMのオーバークロックはGBAとGBASPでは可能ですがゲームボーイミクロでは不可能です。

```
  (おそらく)ゲームボーイミクロのEWRAMはGBAやGBASPのものよりもアクセス速度が遅い、つまりメモリ操作を完了するまでにかかる時間が長いため、EWRAMのウェイトステートを減らしてしまうとまだメモリ操作が完了していないということでしょう。
  実際にEWRAMのオーバークロックが可能かをチェックする際は、オーバークロック後にEWRAMに書き込んだデータを読み出してみて、書き込んだデータと読み出したデータが一致するかどうかを確認するという手法がよく使われます。
```
