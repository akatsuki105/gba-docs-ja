# 割り込み

## 0x0400_0208 - IME - 割り込み有効フラグ (R/W)

割り込み機能を使用するか使用しないかを設定します。 0か1を指定するだけです。

設定が済んだ後、1にして割り込みを発生させます。

```
  Bit   Expl.
  0     割り込み有効フラグ (0=全ての割り込み無効, 1=有効)
  1-31  不使用
```

## 0x0400_0200 - IE - IRQ許可フラグ (R/W)

許可する割り込みの種類を管理するフラグです。 対応するビットが0の場合、IRQは無視されます。

例えば、VBlank割り込みを受け付けるためには

```cpp
  IME = 1;
  IE  = 0bxxxx_xxxx_xxxx_xxx1;
```

```
  Bit   Expl.
  0     LCD V-Blank                    
  1     LCD H-Blank
  2     LCD V-Counter Match
  3     Timer0オーバーフロー
  4     Timer1オーバーフロー
  5     Timer2オーバーフロー
  6     Timer3オーバーフロー
  7     シリアル通信
  8     DMA0(の転送完了)
  9     DMA1
  10    DMA2
  11    DMA3
  12    キー入力
  13    Game Pak (external IRQ source, ゲーム中にカートリッジが抜かれると発生する模様)
  14-15 不使用
```

である必要があります。

## 0x0400_0202 - IF - IRQ発生フラグ (R/W)

発生した割り込みリクエストに対応するフラグが立てられます。

Bit と 割り込みソース の対応は `IE` と同じです。

プログラム側は対応するビットに`0b1`を書き込むことで、割り込みを手動でアクノリッジする必要があり、ビットはクリアされます。

IMEをクリアしたりIEのフラグをクリアしているサイクルでは割り込みが起きることに注意してください。
IEのフラグをクリアする場合は、割り込みチェックのミスマッチが発生しないようにIMEを事前にクリアしておくことをお勧めします。

## BIOS割り込み

割り込みが実行されると、CPUはIRQモードに切り替わり、割り込みベクタ`0x0000_0018`が呼び出されます。このアドレスはBIOS内にあるので、BIOSは常に次のコードを実行してからユーザハンドラに制御を転送します。

```asm
  00000018  b      128h                ; IRQベクタ(BIOSハンドラにジャンプ)
  00000128  stmfd  r13!,r0-r3,r12,r14  ; レジスタをSP_irqに退避
  0000012C  mov    r0,4000000h         ; ptr+4 to 03FFFFFC (mirror of 03007FFC)
  00000130  add    r14,r15,0h          ; retadr for USER handler $+8=138h
  00000134  ldr    r15,[r0,-4h]        ; jump to [03FFFFFC] USER handler
  00000138  ldmfd  r13!,r0-r3,r12,r14  ; SP_irqに退避したレジスタを復帰
  0000013C  subs   r15,r14,4h          ; IRQからリターン (PC=LR-4, CPSR=SPSR)
```

上のコードにあるように、ユーザー定義割り込みハンドラのアドレスは`0x0300_7FFC`に格納されています。

デフォルトでは、WRAMの`0x0300_7F00..0300_7F9F`は割り込みスタックとして予約されています。

## 0x0300_7Fxx(ミラー: 0x03FF_FFxx)

次は、デフォルトで`0x0300_7Fxx`がどのように使われるかを示したものです。

アドレス | サイズ | 内容
---- | ---- | ---- 
0x0300_7F00 | 160 | スタック領域(SP_irq) (6 words/time)
0x0300_7FA0 | 64  | スタック領域(SP_svc) (4 words/time)
0x0300_7FE0 | 16  | Allocated Area
0x0300_7FF0 | 4   | サウンドバッファのアドレス
0x0300_7FF4 | 4   | Allocated Area
0x0300_7FF8 | 2   | Interrupt Check Flag (for IntrWait/VBlankIntrWait functions)
0x0300_7FFC | 4   | ユーザー定義IRQハンドラ(ARMモード)のアドレス

`0x0300_7F00`より前のメモリは、ユーザスタックとユーザデータのための空きメモリです。3つのスタックポインタは、それぞれの領域の先頭で初期化されます。

```cpp
  SP_svc = 0x03007FE0;
  SP_irq = 0x03007FA0;
  SP_usr = 0x03007F00;
```

ユーザーはこれらのアドレスを再定義してスタックを他の場所に移動することができますが、のシステムデータ用のアドレス(`7FE0-7FFF`)だけは固定されています。

## 高速割り込み(FIQ)

GBA(のCPU)は、IRQとFIQの2つの割り込みソースを提供しています。

**GBAではIRQのみを使用します。** 

通常のGBAでは、ハードウェアでFIQを生成する方法はありません。<sup>[1](#fiq)</sup>

ただし、ソフトウェア側でCPSRに書き込みを行いFIQモードに切り替えることで、レジスタ`R8-R12_fiq`をソフトウェアで使用することができます。<sup>[2](#doom)</sup>

しかし、このようなゲームはハードウェアデバッガ（デバッグ目的でFIQを使用していると報告されている）がうまく動作しない可能性があることに注意してください。

<sup id="fiq">1. FIQ信号はVDD35にショートカットされており常にHighになっています。</sup>

<sup id="doom">2. ここ最近でGBAに移植されたゲームがそのようなことをしています。 https://youtu.be/R43k-p9XdIk</sup>
